TLA+ Error Reports That Can Be Mapped to PCal Code
---------------------------------------------------
- Parser Errors

- TLC errors. Expression evaluation in:
   * Initial predicate   
       This seems to just report a single location,
       exactly where the error occurs.
   * process set. (sometimes reports the ProcSet token,
       sometimes it reports no location)
   * expression in statement: can be
      + the expression
      + conjunct of action containing the expression
      + a previous conjunct of that action
      + the last character (and perhaps more) of 
        the first conjunct of that action.
        This seems to be a minor TLC bug

- Error-Trace action location.
  (Double-click needed to go to TLA+ location.)

- Coverage.  Can go to
   * conjunction of action definition
   * variable in UNCHANGED expression
   * variable in vars location

Note: assertion failure error already maps to PCal code location.
(But not if file has been edited since last translator run.)
    
The Structure of the Translation
--------------------------------
<translation> ::=
   <Variables Declaration> 
   <vars Definition>
   [<ProcSet Definition>]0,1
   <Init Definition>
   <Action Def>+
   [<Process Def>]0,1
   <Next Def>
   <Spec Def>
   <Termination Def>

<Action Def> ::=
   <label> ["(self)"]0,1 == 
   "/\" <PC enabling Predicate>
   <Action Body>

<Action Body> ::=
   [   "/\" <Expr> 
     | "/\" <Assignment> 
     | "/\" <If-Then-Else>
   ]*
   ["/\" <pc-assignment>]0,1  \* An outer-most action body must have a pc-assignment
   ["/\" <Unchanged>]0,1      

<Assignment> ::= 
   <Variable>
    "' ="
   [   <Expr>
     | "[" <Variable> "EXCEPT" "!" [ "[self]" ]0,1 
                                   [    "." <String>  
                                     |  "[" <Expr> "]" 
                                   ]*
       "]"
   ]
    
<If-Then-Else> ::=
   "IF" <Expr>
   "THEN" <Action Body>
   "ELSE" <Action Body>
           
<Unchanged> ::=
    "UNCHANGED <<" <Variable> ["," <Variable>]* ">>" 
  | <Variable> "' =" <Variable>

THE GRAMMAR OF ASTs.
-------------------
See PlusCal.tla

DATA STRUCTURE FOR MAPPING
--------------------------

Location == [line : LineNumber, col : ColumnNumber]
  \* location.col = i represents the position to the right of
  \* the i-th character in the line, so i = 0 represents the position
  \* at the beginning of the line.

RegionLoc == [begin : Location, end : Location]


A mapping specifier is a sequence of the following objects:

Paren == [type       : {"begin", "end"} ,
          subType    : {"expression", 
                        "1-1"      used for the def region
                        }
          tlaLoc     : Location,  
            \* I don't think this is needed.
          pcalRegion : Seq(RegionLoc)]
  \* Matching parens logically contain the same pcalRegion
  \* values.  However, it might be most convenient to 
  \* put them only in the end paren.

Token == [type : {"token"},
          subType : {"expression"},
          tlaRegion  : RegionLoc,
          pcalRegion : RegionLoc]
  \* This represents real text in the TLA+ spec


Filler == [type : {"filler"},
           tlaRegion : RegionLoc]
  \* - This is like "EXCEPT", saying that if this is selected, then
  \*   the tlaRegion is determined by the Parens enclosing this object.
  \* - This represents real text in the TLA+ spec, although the tlaRegion
  \*   can represent a segment of text of length 0, which means it
  \*   represents a position in the TLA+ spec.

Ignore == [type : {"ignore"},
           tlaRegion : RegionLoc]
  \* This is text that is logically at the current paren depth
  \* but corresponds to nothing in the PlusCal code--for example,
  \* parentheses put around an expression when it is substituted
  \* for a macro parameter.
  \* - This represents real text in the TLA+ spec

Break == [type      : {"break"},
          tlaRegion : RegionLoc]
  \* This indicates the existence of text in the PlusCal code
  \* that is not part of the region mapped to by the objects
  \* at the current paren depth.  Hence, a TLA+ region at the 
  \* break's paren depth that contains the break maps to a
  \* disconnected regions of the PlusCal code.
  
HOW PlusCal AST CONSTRUCTS ARE MAPPED
---------------------------------
  (e(  ==  left paren mapping to beginning of [e] in PCal code
  )e)  ==  right paren mapping to end of [e] in PCal code
  ^^   ==  Break
  [[   ==  beginning of filler
  ]]   ==  end of filler
  {{   ==  beginning of ignored
  }}   ==  end of ignored
  e    ==  text in TLA+ spec that maps to same string in PCal code
  (e/f) == Text e in TLA+ spec that maps to text f in PCal code


TLAExpr
-------
  PCal Source
    x + param + y   with: parameter param replaced by a + b
                          y replaced by y'
 
  Translation
       x   +              (    a + b    )             +   y'

   (x( x   +   (param( {{ ( }} a + b {{ ) }} )param)  +  (y'/y) )y)


Assign with multiple SingleAssign children
------------------------------------------
  PCal Source
    x[a] := e || x[b] := f || y := g || x[c] := h

  Translation
          /\  /\ x' = [ x EXCEPT 
                            ![a] = e, 
                            ![b] = f, 
                            ![c] = h ]
              /\ y' = g   

    (x[a]( [[ /\ /\ x' = [ x EXCEPT ]]
                       (x[a]( {{ ![ }} a {{ ] }} [[ = ]] e )e)
                       (x[b]( {{ ![ }} b {{ ] }} [[ = ]] f )f)
                     ^^
                       (x[c]( {{ ![ }} c {{ ] }} [[ = ]] h )h)
            [[ ] ]]
            (y( [[ /\ y' = ]] g )y)
    )h)                

Assign with one SingleAssign
----------------------------
  PCal Source
       x := 1

  Translation
      (x( [[/\]] (x'/x) [[ = ]] 1  )1)
   
    or
      (x( [[/\]] (x'/x) [[ = [x EXCEPT ![self] = ]] 1 [[ ] ]] )1)

  PCal Source

       x[a] := e

   Translation

      (x( (x'/x) [[ = {{ ![ }} a [[ = ]] e )e)


LabeledStmt
----------
  PCal 
    lbl: Stmt1; Stmt2; Stmt3

  Produces

   lbl == /\ pc = "lbl"
          Translation(Stmt1)
          Translation(Stmt2)
          Translation(Stmt3)
          /\ pc' = "..."       \* Not present if Stmt3 is a goto

   (lbl( [[ lbl == /\ pc = "lbl" ]]
         Translation(Stmt1)
         Translation(Stmt2)
         Translation(Stmt3)
         [[ /\ pc' = "..." ]]  \* 


LABELED STMT
      l1: x := 1 ; y := 2
      l4: ...

   produces
      l1 == /\ pc = "l1"
            /\ x' = 1
            /\ y' = 2
            /\ pc' = "l4"
            /\ UNCHANGED <<z, w>>

      (l1:( (l1( [[ l1 == /\ pc = "l1" ]] ):)   \****  ):) or )l1) ?
            (x( [[/\]] (x'/x) [[ = ]] 1  )1)
            (y( [[/\]] (y'/y) [[ = ]] 2  )2)
            [[ /\ pc' = "l4"
               /\ UNCHANGED <<z, w>> ]]
      )2)

   Note: In the Exploded AST, the pc = "l1" is obtained from an AST.When
         and the pc' = ... from an AST.Assign.


Call
----
  PCal Code
      procedure P(param1, param2)
      variable pvar1 = e, pvar2 = f
        { plabel: ... }
      ...
          call P(arg1, arg2) ;
   rlbl : ...

   Exploded AST for the Call:
     Assign object with:
       ass |-> << [lhs |-> [var |-> param1, sub |-> null or <<self>>],
                   rhs |-> arg1],
                  [var |-> param2, sub |-> null or <<self>>],
                   rhs |-> arg2],
                  [lhs |-> [var |-> stack, sub |-> null or <<self>>],
                   rhs |-> ...],  \* don't try to deal with this rhs.
                >>

     Assign object with:
       ass |-> << [lhs -> [var |-> pvar1, sub |-> null or <<self>>],
                   rhs |-> e] >>

     Assign object with:
       ass |-> << [lhs -> [var |-> pvar2, sub |-> null or <<self>>],
                   rhs |-> f] >>

     Assign object with:
       ass |-> << [lhs -> [var |-> pc, sub |-> null or <<self>>],
                   rhs |-> "rlbl"] >>

  Produces
     /\  /\ param1' = arg1
         /\ param2' = arg2
         /\ stack' = ...
     /\ pvar1' = e  or [pvar1 EXCEPT ![self] = e]
     /\ pvar2' = f  or  ...
     /\ pc' = ...   or [pc EXCEPT ![self] = ...]

Return
------
   PCal Code
      procedure P(param1, param2)
      variable pvar1 = e, pvar2 = f
        { ... 
          return }
      ...
          call P(arg1, arg2) ;
   rlbl : ...

   Translation
      This produces a lot of stuff that, if selected, should
      map to the return.

CallReturn
----------
   PCal Code:
        call P(param1, param2);
        return

   Translation
      Essentially the same as for Call.

NOTES
-----
- If the translator is modified to use a single TLA+ variable for
two different local PCal variables of the same name, then a variable
name in the TLA+ spec does not map to a unique piece of PCal code
in the <Variables Declaration> and <Init Definition>.  And additional
information will need to be kept to map variable names to the correct
PCal declaration for cases where there is a unique mapping.

- For a multi-assignment such as 

   x[i] := ... || x[j] := ...
   
the <Variable> of an <Assignment> does not correspond to a unique
occurrence of the variable in the PCal code.

- Among the stuff added in the translation are parentheses around expressions.

- The definition section should be handled by a 1-1 mapping between an area 
  of the spec and an area of the code.  That must be fit into any framework.

- Portions of the AST that result from macro expansion can be 
  indicated by a new AST subclass AST.MacroMarker whose objects
  mark the beginning and end of macro expansion, containing the
  location in the PlusCal code of the beginning and end of the
  macro statement. I don't think it needs to indicate the location
  of the the arguments.
